% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/projection.R
\name{getContrastStack}
\alias{getContrastStack}
\alias{getIndexMap}
\alias{contrastProjection}
\alias{projection_fromMap}
\title{Maximum contrast projection of a 3D image stack}
\usage{
getContrastStack(imageStack, w_x, w_y, brushShape = "disc", validate = TRUE)

getIndexMap(contrastStack, smoothing = 0, validate = TRUE)

contrastProjection(imageStack, w_x, w_y = NULL, smoothing = 0,
    brushShape = "disc", interpolation = 0, fix.gaussian.blur = FALSE,
    blur.size = 0, return.all = FALSE)

projection_fromMap(imageStack, indexMap, interpolation = 0, validate = TRUE)
}
\arguments{
\item{imageStack}{A numeric 3D array-like which should ne projected. The 
dimensions should be (spatial_1, spatial_2, numer_of_images)}

\item{w_x}{The size of the window in x-direction}

\item{w_y}{The size of the window in y-direction}

\item{brushShape}{A string indicating the shape of the window. Currently 
supported values are \code{"box", "disc"} and "disc" is the default}

\item{validate}{A boolean value indicating if the variables need to be 
validated or if this function is being called internally, i.e. the variables
have already been validated once. This is only used to marginally speed up 
internal calls to functions and has no bearing on the actual functionality 
of the method.}

\item{contrastStack}{A numeric 3D array-like which contains the local 
contrasts for each image in \code{imageStack} at each pixel}

\item{smoothing}{The size of the median filter window. If this is 0, median 
smoothing is not applied.}

\item{interpolation}{The size of the blurring kernel to use when 
interpolating values at the boundaries of regions in the index map. Set to 
0 for no interpolation.}

\item{fix.gaussian.blur}{A logical value indicating whether the false 
gaussian blur caused by unfocused images should be fixed or not (see 
vignette for more details on this).}

\item{blur.size}{An integer indicating the radius of the gaussian blur. 
Ignored unless \code{fix.gaussian.blur = TRUE}. The total diameter of the 
brush is defined as 2*blur.size+1, meaning that a 'blur.size' value of 0 
will result in a 1x1 pixel brush.}

\item{return.all}{A logical value indicating whether only the projection 
should be returned (FALSE) or if all intermediate results should be returned
as well, including the index map and the contrast stack (TRUE)}

\item{indexMap}{A custom index map according to which the image stack is 
projected. The values must be integers between 1 and the number of layers 
in \code{imageStack}}
}
\value{
\describe{
    \item{contrastProjection}{A 2D matrix corresponding to the maximum 
    contrast projection of \code{imageStack}}
    \item{getIndexMap}{A 2D matrix indicating the z-layer with the maximum 
    contrast at every pixel in the \eqn{(x,y)-plane} of \code{imageStack}}
    \item{getContrastStack}{a 3D array corresponding to the contrast map 
    for every image of \code{imageStack}}
    \item{projection_fromMap}{A 2D matrix corresponding to the maximum 
    contrast projection of \code{imageStack}}
}
}
\description{
Projects a z-stack of 2D images according to the highest local
contrast. Optionally, median smoothing can be applied to the resulting
projection index map prior to the projection itself.
}
\details{
The local contrast for every image in the stack is determined using
\code{calcContrast}. \code{getContrastStack} returns this stack of contrast 
maps. Then, the z-layer with the highest local contrast is determined for 
each pixel in the \eqn{(x,y)}-plane, resulting in an index map with the 
same spatial dimensions as the input images. This index map can then be 
smoothed with a median filter if desired. \code{getIndexMap} returns this 
index map. Lastly, the image stack is projected into the \eqn{(x,y)}-plane 
using this index map to determine which z-layer to use at every pixel.
\code{contrastProjection} returns this fully projected image.

The \code{brushShape} indicates the shape of the window over which to 
calculate the variance. Depending on the symmetry of the objects being 
imaged, the window shape may have a significant impact on the quality of 
the projection.

If an object lies in several focal plains then the projection may include 
some artifical boundaries at the edges of the regions in each focal plain. 
Linear interpolation between the two layers at their boundaries serves to 
eliminate this problem. The \code{interpolation} size gives the size of the 
kernel to use for blurring the boundaries between individual regions of the 
index map. The projection values at these boundaries are then interpolated 
based on the non-integer values on the index maps. For example, if a pixel 
on the index map has the value 7.25, then the projected value at this pixel 
is 75% of the intensity in z-layer 7 and 25% of the intensity in layer 8.

If a very bright object lies on a dark background, then the gaussian 
blurring of the unfocused image stacks can create a brighter ring structure 
around this object. Fixing this involves Voronoi propagation into the 
regions directly surrounding bright objects. This correction only makes 
sense if there is a clear differentiation between fore- and background 
in the image. A perfect segmentation is unnecessary as the rings will only 
appear around exceptionally bright objects, which are easy to segment.
}
\section{Functions}{
\itemize{
\item \code{getContrastStack}: Get the full stack of contrast maps for each 
image in the image stack

\item \code{getIndexMap}: Get the index map (with or without smoothing)
which indicates the layer corresponding to the highest contrast for each 
pixel in the \eqn{(x,y)}-plane

\item \code{projection_fromMap}: Get the index map (with or without smoothing)
which indicates the layer corresponding to the highest contrast for each 
pixel in the \eqn{(x,y)}-plane
}}

\examples{
print(contrastProjection)
print(getIndexMap)
print(getContrastStack)
}
\author{
Jan Sauer
}
\keyword{array}
